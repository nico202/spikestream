//SpikeStream includes
#include "NRMRandom.h"
using namespace spikestream;

//Other includes
#include "gmpxx.h"
#include <iostream>
using namespace std;

//Initialize static variables
RandomSeed NRMRandom::seed = { 1, 0 };


/*-------------------------------------------------------*/
/*-----                PUBLIC METHODS               -----*/
/*-------------------------------------------------------*/

/*! Returns a new random number */
int NRMRandom::getRandNum(int num){
	return num ? (int)( generateRandNum() % (num) ) : 0;
}


/*! Sets the random seed */
void  NRMRandom::setSeed(unsigned int newSeed){
		seed.lo = newSeed;
		seed.hi = 0;
}


/*--------------------------------------------------------*/
/*-----                PRIVATE METHODS               -----*/
/*--------------------------------------------------------*/

/*! Generates a new random number.
	This is a reworking of the NRM assembler code for random number generation. Porting the assembler
	to GCC assembler proved too complicated, so variables are used instead along with a special multiplication
	function. The random sequence should be the same as that generated by NRM because the connection pattern
	depends on it. */
long NRMRandom::generateRandNum(void){
	unsigned int ebxOut = 0;
	unsigned int esiOut = 0;
	unsigned int tmpVar = 0;
	unsigned int tmpEax = 0;
	unsigned int tmpEbx = 0;
	unsigned int tmpEcx = 0;
	unsigned int tmpEdx = 0;
	unsigned int tmpEsi = 0;

	//mov	eax, ebxIn /* Copies Seed.hi into the eax register */
	tmpEbx = seed.hi;
	tmpEax = tmpEbx;

	//mov esi, esiIn /* Copies Seed.lo into the esi register MY ADDITION */
	tmpEsi = seed.lo;

	//mov	ecx, 015A4h /* Copies 1010110100100 into ecx register */
	tmpEcx = 0x15A4;

	//mov	ebx, 04E35h /* Copies 100111000110101 into ebx register */
	tmpEbx = 0x4E35;

	//test eax, eax /* Checks to see if eax is zero */
	//jz	nohi1 /* Jumps to nohil: if it is zero skip next statement if it is zero*/
	if(tmpEax != 0){
		//mul	ebx /* Multiplies ebx * eax  and stores result in eax. eax now contains 04E35h * Seed.hi. edx contains the top part of the number if the calcuation overflows. */
		multiply64Bit(tmpEax, tmpEbx, tmpEdx);
	}

	//nohi1:
	//xchg ecx, eax /* Swap eax and ecx. eax now contains 015A4h, ecx contains zero because we reached this point after a check to see if eax is zero */
	tmpVar = tmpEcx;
	tmpEcx = tmpEax;
	tmpEax = tmpVar;

	//mul	esi /* Multiply esi * eax and store result in eax. eax now contains Seed.lo * 015A4h. */
	//tmpEax *= tmpEsi;
	multiply64Bit(tmpEax, tmpEsi, tmpEdx);

	//add	eax, ecx /* eax now contains Seed.lo * 015A4h + 0 */
	tmpEax += tmpEcx; //ecx contains exchanged value of tmpSeedHi.

	//xchg eax, esi /* eax now contains Seed.lo */
	tmpVar = tmpEsi;
	tmpEsi = tmpEax;
	tmpEax = tmpVar;

	//mul	ebx /* eax now contains 04E35h * Seed.lo */
	multiply64Bit(tmpEax, tmpEbx, tmpEdx);

	//add	edx, esi /* esi contains result of previous calculations, carry flag is reset*/
	tmpEdx += tmpEsi;

	//add	eax, 1
	tmpEax += 1;

	//adc	edx, 0 /* Adds 0 + the carry flag to edx. Carry flag will be set if the previous calculation exceeds maximum size of integer. */
	if(tmpEax == 0)
		++tmpEdx;

	//mov	ebxOut, eax
	ebxOut = tmpEax;

	//mov	esiOut, edx
	esiOut = tmpEdx;

	seed.lo = ebxOut;
	seed.hi = esiOut;
	return esiOut & 0x7fffffff;
}


/*! Multiplies the two numbers storing the result in the multiplicand and the overflow in the overflow.
	Intended to duplicate what happens in assembler, where the overflow ends up in edx. */
void NRMRandom::multiply64Bit(unsigned int& multiplicand, unsigned int multiplier, unsigned int& overflow){
	//Create large number to hold the result
	mpz_t  tmpNum;
	mpz_init (tmpNum);

	//Copy multiplicand into large number variable
	mpz_set_ui (tmpNum, multiplicand);

	//Carry out multiplication
	mpz_mul_si (tmpNum, tmpNum, multiplier);

	//Bottom 32 bits is the multiplicand, just carry out result using standard integer arithmetic and the number will overflow
	multiplicand *= multiplier;

	//Overflow is the product divided by 2^32
	mpz_fdiv_q_ui(tmpNum, tmpNum, 4294967295);
	overflow = mpz_get_ui (tmpNum);

	//Clean up
	mpz_clear(tmpNum);
}
